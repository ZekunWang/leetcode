/*
Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the 
researcher's h-index.

According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h 
citations each, and the other N âˆ’ h papers have no more than h citations each."

For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had 
received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the 
remaining two with no more than 3 citations each, his h-index is 3.

Note: If there are several possible values for h, the maximum one is taken as the h-index.

Hint:
An easy approach is to sort the array first.
What are the possible values of h-index?
A faster approach is to use extra space.
*/

class Solution {
public:
    int hIndex(vector<int>& citations) {
        //return solution1(citations);      //sort
        //return solution2(citations);      //no sort
        //return solution2(citations);        //no sort with unordered_map
        return solution4(citations);        //O(n) space
    }
private:
    int solution1(vector<int> &v){
        int sz = v.size(), count(sz), h(sz);
        sort(v.begin(), v.end());
        for(int i = sz - 1; i >= 0 && count;){
            if(v[i] < h) h--;
            else i--;
            count--;
        }
        return count ? h-1 : h;
    }
    int solution2(vector<int> &v){
        int sz(v.size()), count(sz),  h(sz), tmphi;
        bool setRework = true;
        for(int i = sz - 1; i >= 0 && count; i--){
            if(v[i] >= h) count--;
            else{
                if(setRework) {tmphi = i; setRework = false;}
                if(i + 1 == count){
                    h--;
                    count--;
                    if(v[tmphi] == h){
                        count--; 
                        setRework = true;
                    }
                    for(int j = tmphi - 1; j >= i && count > 0; j--){
                        if(v[j] == h) count--;
                        else if(setRework && v[j] < h)
                            tmphi = j; setRework = false;
                    }
                }
            }
        }
        return count > 0 ? h-1 : h;
    }
    int solution3(vector<int> &v){
        int sz(v.size()), count(sz), h(sz), remain(sz);
        if(!sz) return 0;
        unordered_map<int, int> m;
        auto tmphi = m.begin();
        bool setRework = true;
        for(int i = 0; i < sz; i++)
            m[v[i]]++;
        for(auto i = m.begin(); i != m.end() && count; i++){
            if(i->first >= h) count -= i->second;
            else{
                if(setRework) {tmphi = i; setRework = false;}
                if(count >= remain){
                    h -= i->second;
                    count -= i->second;
                    if(tmphi->first == h){
                        count -= tmphi->second;
                        tmphi++;
                        setRework = true;
                    }
                    for(auto j = tmphi; j != i && count > 0; j++){
                        if(j->first == h) count -= j->second;
                        else if(setRework && j->first < h)
                            tmphi = j; setRework = false;
                    }
                    if(i->first == h) count -= i->second;
                }
            }
            remain -= i->second;
        }
        return count > 0 ? h-1 : h;
    }
    int solution4(vector<int> &v){
        int sz(v.size()), count[sz+1] = {};
        for(int i = 0; i < sz; i++)
            count[v[i] >= sz ? sz : v[i]]++;
        for(int i = sz; i >= 0; i--){
            if(count[i] >= i) return i;
            else count[i-1] += count[i];
        }
    }
};
