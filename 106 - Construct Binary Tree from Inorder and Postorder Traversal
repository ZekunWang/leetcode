/*
Given inorder and postorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.
*/

class Solution {

public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return solution1(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);
    }
private:
    TreeNode* solution1(vector<int>& in, int is, int ie, vector<int>& post, int ps, int pe){
        if(ps > pe || is > ie) return NULL;
        TreeNode *node = new TreeNode(post[pe]);
        int pos(0);
        while(in[pos] != node->val) pos++;
        node->left = solution1(in, is, pos - 1, post, ps, ps + pos - 1 - is);
        node->right = solution1(in, pos + 1, ie, post, pe - ie + pos, pe - 1);
        return node;
    }
};
