/*
Compare two version numbers version1 and version2.
If version1 > version2 return 1, if version1 < version2 return -1, otherwise return 0.

You may assume that the version strings are non-empty and contain only digits and the . character.
The . character does not represent a decimal point and is used to separate number sequences.
For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the 
second first-level revision.

Here is an example of version numbers ordering:

0.1 < 1.1 < 1.2 < 13.37
*/

class Solution {
public:
    int compareVersion(string version1, string version2) {
        //return solution1(version1, version2);       //iterative
        return solution2(version1, -1, version1.length(), version2, -1, version2.length());       //recursive
    }
private:
    int solution1(string v1, string v2) {
        int sz1 = v1.length(), sz2 = v2.length(), num1(0), num2(0), i1(-1), i2(-1);
        while(i1 < sz1 && i2 < sz2){            //compare numbers when both not reach end of string
            num1 = getNum(v1, ++i1, sz1);
            num2 = getNum(v2, ++i2, sz2);
            if(num1 != num2) return num1 > num2 ? 1 : -1;
        }
        if(num1 != num2) return num1 > num2 ? 1 : -1;   //compare last numbers before loop breaks
        while(i1 < sz1)         //check remaining numbers for version 1 if has
            if(getNum(v1, ++i1, sz1) != 0) return 1;
        while(i2 < sz2)         //check remaining numbers for version 2 if has
            if(getNum(v2, ++i2, sz2) != 0) return -1;
        return 0;               //equai if all remaining numbers are 0s or no remaining numbers
    }
    int getNum(string v, int &pos, int sz){     //get number based on '.' and lengh of string
        int num(0);
        while(pos < sz){
            if(v[pos] == '.') break;
            num = 10 * num + (v[pos++] - '0');
        }
        return num;
    }
    int solution2(string v1, int i1, int len1, string v2, int i2, int len2){
        if(i1 == len1 && i2 == len2) return 0;
        if(i1 == len1) while(getNum(v2, ++i2, len2) != 0) return -1;
        else if(i2 == len2) while(getNum(v1, ++i1, len1) != 0) return 1;
        else{
            int num1 = getNum(v1, ++i1, len1), num2 = getNum(v2, ++i2, len2);
            if(num1 != num2) return num1 > num2 ? 1 : -1;
        }
        return solution2(v1, i1, len1, v2, i2, len2);
    }
};
